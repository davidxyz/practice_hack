{
  "Subtree": {
    "description": "Executes a behavior tree (.bt) as a single behavior and returns the status of the subtree.",
    "type": "leaf",
    "args": [
      "Subtree",
      "Function",
      "Function"
    ],
    "meta": [
      {
        "field": "fileName",
        "description": "Select a subtree.",
        "defaultValue": "null"
      },
      {
        "field": "getNotepad",
        "description": "Enter optional information to return an object that will be this tree's notepad.",
        "defaultValue": "() => {\n    return {};\n}"
      },
      {
        "field": "setResult",
        "description": "Enter optional code that will be called with the subtree's results with the subtree is done.",
        "defaultValue": "(treeResult) => {\n}"
      }
    ]
  },
  "SubtreeJs": {
    "description": "Dynamically executes a behavior tree (.bt) as a single behavior. This behavior returns the status of the subtree.",
    "type": "leaf",
    "args": [
      "Function",
      "Function",
      "Function"
    ],
    "meta": [
      {
        "field": "getFilename",
        "description": "Specify a subtree.",
        "defaultValue": "(callback) => {\n}"
      },
      {
        "field": "getNotepad",
        "description": "Enter optional information to return an object that will be this tree's notepad.",
        "defaultValue": "() => {\n    return {};\n}"
      },
      {
        "field": "setResult",
        "description": "Enter optional code that will be called with the subtree's results with the subtree is done.",
        "defaultValue": "(treeResult) => {\n}"
      }
    ]
  },
  "PlayAnimation": {
    "description": "Plays an animation file (.keys). Succeeds when the animation is finished.",
    "type": "leaf",
    "args": [
      "Animation",
      "Function"
    ],
    "meta": [
      {
        "field": "fileName",
        "description": "Select the animation file to play.",
        "defaultValue": "null"
      },
      {
        "field": "animModifier",
        "description": "Enter optional code to modify the animation's playback.",
        "defaultValue": "(animation) => {\n}"
      }
    ]
  },
  "PlayAudio": {
    "description": "Plays a single audio source. The audio format is any format supported by HTML5 audio. Succeeds when the audio file is finished playing",
    "type": "leaf",
    "args": ["Audio"],
    "meta": [
      {
        "field": "path",
        "description": "Enter the audio file path.",
        "defaultValue": "null"
      }
    ]
  },
  "LookAt": {
    "description": "Creates body and eye animations for looking at a point in 3D space",
    "type": "leaf",
    "args": ["Function",
             "boolean",
             "Function"],
    "meta": [
      {
        "field": "target",
        "description": "Return the x, y, and z coordinates Jibo should look at.",
        "defaultValue": "() => {\n    return {x: 0, y: 0, z: 0};\n}"
      },
      {
        "field": "lookAtMode",
        "description": "True for continuous mode look at. False for single-shot look at.",
        "defaultValue": false
      },
      {
        "field": "lookAtModifier",
        "description": "Enter optional code to modify the lookAt behavior.",
        "defaultValue": "(lookAt) => {\n}"
      }
    ]
  },
  "Blink": {
    "description": "Animates Jibo's eye to blink once.",
    "type": "leaf",
    "args": [],
    "meta": []
  },
  "TextToSpeech": {
    "description": "Creates speech output for Jibo.",
    "type": "leaf",
    "args": [
        "SSML",
        "Function"
    ],
    "meta": [
      {
        "field": "words",
        "description": "Enter text for Jibo to say. Takes plain text or SSML markup.",
        "defaultValue": "Hello"
      },
      {
        "field": "onWord",
        "description" : "Enter optional code to execute each time Jibo says a single word.",
        "defaultValue": "(word) => {\n}"
      }
    ]
  },
  "TextToSpeechJs": {
    "description": "Dynamically creates speech output for Jibo.",
    "type": "leaf",
    "args": [
        "Function",
        "Function"
    ],
    "meta": [
      {
        "field": "getWords",
        "description": "Return what you want Jibo to say.",
        "defaultValue": "(callback) => {\n    callback('Hello');\n}"
      },
      {
        "field": "onWord",
        "description": "Enter optional code to execute each time Jibo says a single word.",
        "defaultValue": "(word) => {\n}"
      }
    ]
  },
  "StartOnAnimEvent": {
    "description": "Prevents the behavior it's decorating from starting until a specified event is received from an animation.",
    "type": "decorator",
    "args": [
      "string",
      "Function"
    ],
    "meta": [
      {
        "field": "eventName",
        "description": "Specify the event name (set on the animation's Event Layer) on which the animation should start."
      },
      {
        "field": "onReceived",
        "description": "Enter optional code to execute after the event is received but before the behavior starts.",
        "defaultValue": "(animFileName, payload) => {\n}"
      }
    ]
  },
  "StartOnEvent": {
    "description": "Prevents behavior it's decorating from starting until specified event is received from the global emitter.",
    "type": "decorator",
    "args": [
      "string",
      "Function"
    ],
    "meta": [
      {
        "field": "eventName",
        "description": "Specify the event name you want to listen for the component to start."
      },
      {
        "field": "onReceived",
        "description": "This function is called after the event was received but before the component starts.",
        "defaultValue": "() => {\n}"
      }
    ]
  },
  "SucceedOnEvent": {
    "description": "Forces the behavior it's decorating to succeed when an event is received from the global emitter.",
    "type": "decorator",
    "args": [
      "string",
      "Function"
    ],
    "meta": [
      {
        "field": "eventName",
        "description": "Specify the event name you want to listen for the component to start."
      },
      {
        "field": "onReceived",
        "description": "This function is called after the event was received along with any payload.",
        "defaultValue": "() => {\n}"
      }
    ]
  },
  "SucceedOnEmbedded": {
    "description": "Succeeds a behavior upon hearing a built-in listening rule.",
    "type": "decorator",
    "args": [
      ["enum",
        {
          "label": "Hey Jibo",
          "display": "Hey Jibo",
          "value": "hey_jibo"
        }
      ],
      "Function"
    ],
    "meta": [
      {
        "field": "ruleName",
        "description": "Specify the name of the embedded rule you want to listen for (hey_jibo).",
        "defaultValue": "hey_jibo"
      },
      {
        "field": "getListener",
        "description": "(listener), event emitter for hey-jibo (asr, spkr) and error events.",
        "defaultValue": "(listener) => {\n\tlistener.on('hey-jibo', (asrResult, speakerIds) => {\n\n\t});\n}"
      }
    ]
  },
  "ListenEmbedded": {
    "description": "Listens only for an embedded rule (hey_jibo)",
    "type": "leaf",
    "args": [
      ["enum",
        {
          "label": "Hey Jibo",
          "display": "Hey Jibo",
          "value": "hey_jibo"
        }
      ],
      "Function"
    ],
    "meta": [
      {
        "field": "ruleName",
        "description": "Specify the name of the embedded rule you want to listen for (hey_jibo).",
        "defaultValue": "hey_jibo"
      },    
      {
        "field": "getListener",
        "description": "(listener), event emitter for hey-jibo (asr, spkr) and error events.",
        "defaultValue": "(listener) => {\n\tlistener.on('hey-jibo', (asrResult, speakerIds) => {\n\n\t});\n}"
      }
    ]
  },
  "Listen": {
    "description": "Tells Jibo to listen for auditory input using Natural Language Understanding (NLU).",
    "type": "leaf",
    "args": [
      "Function",
      "Rule",
      "Function"
    ],
    "meta": [
      {
        "field": "getOptions",
        "description": "Set the dictionary of options that will be returned for the listening task.",
        "defaultValue": "() => {\n    let options = {\n        heyJibo: false,\n        detectEnd: false,\n        incremental: false,\n        authenticateSpeaker: ''\n    }\n    return options;\n}"
      },
      {
        "field": "ruleFile",
        "description": "Specify the file path for the rule to use to parse Listen results.",
        "defaultValue": "null"
      },
      {
        "field": "getListener",
        "description": "Enter code to execute when Jibo has heard input. (listener), event emitter for hey-jibo (asr, spkr) and timeout() events.",
        "defaultValue": "(listener) => {\n    listener.on('cloud', (asrResult, speakerIds) => {\n\n    });\n}"
      }
    ]
  },
  "SucceedOnListen": {
    "description": "Succeeds a behavior upon hearing a custom Natural Language Understand (NLU) rule.",
    "type": "decorator",
    "args": [
      "Function",
      "Rule",
      "Function"
    ],
    "meta": [
      {
        "field": "getOptions",
        "description": "Set the dictionary of options that will be returned for the listening task.",
        "defaultValue": "() => {\n    let options = {\n        heyJibo: false,\n        detectEnd: false,\n        incremental: false,\n        authenticateSpeaker: ''\n    }\n    return options;\n}"
      },
      {
        "field": "ruleFile",
        "description": "Specify the file path for the rule to use to parse Listen results.",
        "defaultValue": "null"
      },
      {
        "field": "getListener",
        "description": "Enter code to execute when Jibo has heard input. (listener), event emitter for hey-jibo (asr, spkr) and timeout() events.",
        "defaultValue": "(listener) => {\n    listener.on('cloud', (asrResult, speakerIds) => {\n\n    });\n}"
      }
    ]
  },
  "ListenJs": {
    "description": "Tells Jibo to listen for auditory input using Natural Language Understanding (NLU).",
    "type": "leaf",
    "args": [
      "Function",
      "Function",
      "Function"
    ],
    "meta": [
      {
        "field": "getOptions",
        "description": "Set the dictionary of options that will be returned for the listening task.",
        "defaultValue": "() => {\n    let options = {\n        heyJibo: false,\n        detectEnd: false,\n        incremental: false,\n        authenticateSpeaker: ''\n    }\n    return options;\n}"
      },
      {
        "field": "getRule",
        "description": "Pass a custom listening rule into the callback.",
        "defaultValue": "(callback) => {\n    callback(\"TopRule = $* Hello World $*;\");\n}"
      },
      {
        "field": "getListener",
        "description": "Enter code to execute when Jibo has heard input. (listener), event emitter for cloud (asr, spkr), hey-jibo (asr, spkr), timeout (), incremental (asr, stop()), and end-of-speech() results.",
        "defaultValue": "(listener) => {\n    listener.on('cloud', (asrResult, speakerIds) => {\n\n    });\n}"
      }
    ]
  },
  "SucceedOnListenJs": {
    "description": "Succeeds a behavior upon hearing a custom Natural Language Understand (NLU) rule.",
    "type": "decorator",
    "args": [
      "Function",
      "Function",
      "Function"
    ],
    "meta": [
      {
        "field": "getOptions",
        "description": "Set the dictionary of options that will be returned for the listening task.",
        "defaultValue": "() => {\n    let options = {\n        heyJibo: false,\n        detectEnd: false,\n        incremental: false,\n        authenticateSpeaker: ''\n    }\n    return options;\n}"
      },
      {
        "field": "getRule",
        "description": "Pass a custom listening rule into the callback.",
        "defaultValue": "() => {\n    callback(\"TopRule = $* Hello World $*;\");\n}"
      },
      {
        "field": "getListener",
        "description": "Enter code to execute when Jibo has heard input. (listener), event emitter for cloud (asr, spkr), hey-jibo (asr, spkr), timeout (), incremental (asr, stop()), and end-of-speech() results.",
        "defaultValue": "(listener) => {\n    listener.on('cloud', (asrResult, speakerIds) => {\n\n    });\n}"
      }
    ]
  },
  "TakePhoto": {
    "description": "Attempts to take a photo and return the image url in the onPhoto callback",
    "type": "leaf",
    "args": [
      ["enum",
        {
          "label": "Preview (640x360)",
          "display": "Preview",
          "value": 1
        },
        {
          "label": "Full (1280x720)",
          "display": "Full",
          "value": 2
        }
      ],
      "Function"
    ],
    "meta": [
      {
        "field": "photoRes",
        "description": "Specify the resolution of the photo you want to take. 1 for Preview (640x360) or 2 for Full (1280x720)",
        "defaultValue": 2
      },
      {
        "field": "onPhoto",
        "description" : "Set optional code to execute after the photo is taken. If successful, returns imageUrl; otherwise, returns error.",
        "defaultValue": "(error, imageUrl) => {\n}"
      }
    ]
  },
  "ReadBarcode": {
    "description": "Attempts to read a barcode or QRcode and returns the barcode data",
    "type": "leaf",
    "args": [
      "Function"
    ],
    "meta": [
      {
        "field": "onBarcode",
        "description" : "Enter the code that will be called when the barcode is read. If successful, returns barcode/QRcode data; otherwise, returns error.",
        "defaultValue": "(error, data) => {\n}"
      }
    ]
  }
}
